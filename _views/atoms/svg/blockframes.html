<!-- @format -->

{% include "atoms/svg/Blockframe Library.svg" %}
<svg id="container">I'm just here to provide bounding boxes for elements</svg>
<script type="module">
	import { SVG } from "https://cdn.skypack.dev/@svgdotjs/svg.js@3.1.1";
	import { random } from "https://cdn.skypack.dev/@georgedoescode/generative-utils@1.0.37";

	console.clear();
	const COLCOUNT = 18; // The number of columns
	const ROWCOUNT = 16; // The maximum number of rows in a given column
	const THRESHOLD = 16; // The row index where blocks are conditional
	const SIZE = 100; // The size of each block (square)
	const ANGLE = 0; // The skew angle for each block (pos and neg)
	const BRIGHTNESS = 0.25; // Brightness factor for even columns
	// The IDs for the blockframes available in the source SVG
	const TYPES = [
		"Article",
		"Calendar",
		"Cart",
		"Contact",
		"Landing",
		"Map",
		"Timeline",
	];
	// The SVG supplying the blockframes copied into the grid
	const SRC = document.getElementById("BlockframeLibrary");
	// console.log(SRC);
	SRC.classList.add("hidden");

	let draw, colors, colorPalette;

	function addBlockFrame(chrome, colors) {
		switch (random(TYPES)) {
			case "About":
				drawAbout(chrome, colors);
				break;
			case "Calendar":
				drawCalendar(chrome, colors);
				break;
			case "Article":
				drawArticle(chrome, colors);
				break;
			case "Landing":
				drawLanding(chrome, colors);
				break;
			case "Cart":
				drawCart(chrome, colors);
				break;
			case "Contact":
				drawContact(chrome, colors);
				break;
			case "Map":
				drawMap(chrome, colors);
				break;
			case "Timeline":
				drawTimeline(chrome, colors);
				break;
		}
	}

	function paint(element, color, opacity) {
		switch (element.nodeName) {
			// Container elements
			case "svg":
			case "g":
			case "defs":
			case "symbol":
			case "use":
				element.childNodes.forEach((child) => {
					paint(child, color, opacity);
				});
				break;
			// Basic shapes
			case "rect":
			case "circle":
			case "ellipse":
			case "line":
			case "polyline":
			case "polygon":
			case "path":
				element.setAttribute("fill", color);
				if (opacity) {
					element.setAttribute("opacity", opacity);
				}
				// element.setAttribute('stroke', "#000000");
				break;

			default:
				// DO NOTHING
				// console.log("unknown element: " + element.nodeName);
				break;
		}
	}

	function getColors(len) {
		let colorList = [...colors];
		let set = [];
		for (var i = 0; i < len; i++) {
			// Get random index for this array of colors
			let colorIndex = random(0, colorList.length - 1, true);
			// Add the color to the result
			set.push(colorList[colorIndex]);
			// remove that color from the options
			colorList.splice(colorIndex, 1);
		}
		// console.log(set);
		return set;
	}

	// Calculate the Euclidean distance between two colors
	function colorDistance(color1, color2) {
		const r1 = parseInt(color1.substring(1, 3), 16);
		const g1 = parseInt(color1.substring(3, 5), 16);
		const b1 = parseInt(color1.substring(5, 7), 16);

		const r2 = parseInt(color2.substring(1, 3), 16);
		const g2 = parseInt(color2.substring(3, 5), 16);
		const b2 = parseInt(color2.substring(5, 7), 16);

		return Math.sqrt(
			Math.pow(r2 - r1, 2) + Math.pow(g2 - g1, 2) + Math.pow(b2 - b1, 2)
		);
	}
	// Find the color with the greatest distance
	function findFarthestColor(source, colors) {
		let maxDistance = 0;
		let result = 0;

		for (let i = 0; i < colors.length; i++) {
			const distance = colorDistance(source, colors[i]);
			if (distance > maxDistance) {
				maxDistance = distance;
				result = colors[i];
			}
		}
		return result;
	}

	// Function to create and apply a filter to lower brightness
	function createFilters(e) {
		// Append the filter to the SVG's defs section
		let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
		e.node.appendChild(defs);
		defs.appendChild(getBrightnessFilter());
	}

	function getBrightnessFilter() {
		// Create a filter element
		const filter = document.createElementNS(
			"http://www.w3.org/2000/svg",
			"filter"
		);
		filter.setAttribute("id", "brightness");

		// Create feComponentTransfer element
		const feComponentTransfer = document.createElementNS(
			"http://www.w3.org/2000/svg",
			"feComponentTransfer"
		);

		// Create feFuncR, feFuncG, feFuncB elements and set their attributes
		["R", "G", "B"].forEach((channel) => {
			const feFunc = document.createElementNS(
				"http://www.w3.org/2000/svg",
				`feFunc${channel}`
			);
			feFunc.setAttribute("type", "linear");
			feFunc.setAttribute("slope", BRIGHTNESS);
			feComponentTransfer.appendChild(feFunc);
		});

		// Append feComponentTransfer to filter
		filter.appendChild(feComponentTransfer);
		return filter;
	}

	function paintChrome(chrome, colors) {

		// Set size and scale
		// chrome.setAttribute("transform", `scale(${scale})`);

		// BACKGROUND
		var background = chrome.querySelector(".background");
		paint(background, colors[0]);

		// TOOLBAR
		var toolbar = chrome.querySelector(".toolbar");
		// background
		var tbg = toolbar.querySelector(".background");
		paint(tbg, findFarthestColor(colors[0], colors));
		tbg.setAttribute("opacity", 0.25);
		tbg.setAttribute("style", "mix-blend-mode: hard-light;");

		// dots
		var dots = toolbar.querySelector(".dots");
		paint(dots, colors[0]);
	}

	function drawCalendar(chrome, colors) {
		var calendar = SRC.querySelector(".Calendar").cloneNode(true);
		var controls = calendar.querySelector(".controls");
		var days = calendar.querySelector(".days");
		var background = calendar.querySelector(".background");
		background.setAttribute("opacity", 0.5);
		paint(controls, colors[0]);
		paint(days, colors[1]);
		calendar.removeAttribute("visibility");
		chrome.appendChild(calendar);
	}

	function drawCart(chrome, colors) {
		var cart = SRC.querySelector(".Cart").cloneNode(true);
		var rows = cart.querySelectorAll(".rows");
		paint(rows, findFarthestColor(colors[0], colors), 0.75);
		cart.removeAttribute("visibility");
		chrome.appendChild(cart);
	}

	function drawArticle(chrome, colors) {
		var article = SRC.querySelector(".Article").cloneNode(true);
		var text = article.querySelector(".text");
		paint(text, findFarthestColor(colors[0], colors), 1);
		paintImage(
			article.querySelector(".image"),
			colors
		);
		var sidebar = article.querySelector(".sidebar");
		paint(sidebar, findFarthestColor(colors[0], colors), 1);
		article.removeAttribute("visibility");
		chrome.appendChild(article);
	}

	function drawLanding(chrome, colors) {
		var landing = SRC.querySelector(".Landing").cloneNode(true);
		var text = landing.querySelector(".text");
		paint(text, findFarthestColor(colors[0], colors), 1);
		paintImage(
			landing.querySelector(".image"),
			colors
		);
		landing.removeAttribute("visibility");
		chrome.appendChild(landing);
	}

	function drawContact(chrome, colors) {
		var block = SRC.querySelector(".Contact").cloneNode(true);
		var background = block.querySelector(".background");
		var fields = block.querySelector(".fields");
		var title = block.querySelector(".title");
		var button = block.querySelector(".submit");
		paint(background, findFarthestColor(colors[0], colors));
		paint(fields, colors[1], 0.75);
		paint(title, colors[1]);
		paint(button, colors[1]);
		block.removeAttribute("visibility");
		chrome.appendChild(block);
	}

	function drawMap(chrome, colors) {
		// Get the article element and copy it into the grid
		var block = SRC.querySelector(".Map").cloneNode(true);
		var background = block.querySelector(".background");
		var streets = block.querySelector(".streets");
		var pin = block.querySelector(".pin");
		var text = block.querySelector(".text");
		paint(background, colors[0]);
		paint(streets, colors[1]);
		paint(pin, colors[3], 1);
		paint(text, colors[1]);
		streets.setAttribute("opacity", 1);
		block.removeAttribute("visibility");
		chrome.appendChild(block);
	}

	function drawTimeline(chrome, colors) {
		var block = SRC.querySelector(".Timeline").cloneNode(true);
		var chop = block.querySelector(".chop");
		var bullets = block.querySelector(".bullets");
		var history = block.querySelector(".history");
		chop.setAttribute("opacity", 1);
		chop
			.querySelector(".background")
			.setAttribute("fill", findFarthestColor(colors[1], colors));
		chop
			.querySelector(".star")
			.setAttribute("fill", colors[0]);
		paint(bullets, colors[3], 1);
		paint(history, colors[2], 1);
	}
	//#
	function paintImage(image, colors) {
		var base = findFarthestColor(colors[0], colors);
		var background = image.querySelector(".background"
		);
		paint(background, "#FFFFFF");
		var mountains = image.querySelector(".mountains"
		);
		paint(mountains, base, 0.5);
		var sun = image.querySelector(".sun");
		paint(sun, base, 1);

	}

	// BUILD A NEW GRID

	function generateNewGrid() {
		// Clear the view
		// document.querySelector(".blockframe").innerHTML = "";
		drawGrid();
	}

	async function drawGrid() {
		const grid = SVG() // Create the SVG
			.size("100%", "100%")
			.viewbox(`0 0 ${COLCOUNT * SIZE} ${ROWCOUNT * SIZE} `);
		// createFilters(grid);
		for (let r = 0; r < ROWCOUNT; r++) {
			for (let c = 0; c < COLCOUNT; c++) {
				if (r <= c + THRESHOLD) {
					// Knowing odd/even keeps the last items lined up rather than dangling
					if (c % 2 === 0 || r < c + THRESHOLD) {
						drawBlock(grid, r, c);
					}
				}
			}
		}



		// Convert SVG content to a data URL
		// console.log(grid.svg());
		const encodedSVG = escape(grid.svg()); // encodeURIComponent(grid.svg());
		// console.log(encodedSVG);
		const svgDataURL = `url("data:image/svg+xml;charset=UTF-8,${encodedSVG}")`;
		// console.log(escape(svgDataURL));
		// Apply the SVG as the background image
		var container = document.getElementsByClassName("bg-blockframes")[0];
		// console.log(container);
		// container.appendChild(grid.svg());
		container.style.backgroundImage = svgDataURL;
		// VIEWS.forEach(view => view.classList.add('bg-[' + svgDataURL) + ']');
		// Remove the temporary container
		document.getElementById("container").remove();
		document.getElementById("BlockframeLibrary").remove();
	}

	function drawBlock(grid, r, c) {
		const chrome = SRC.querySelector(".Chrome").cloneNode(true);
		chrome.classList.add("blockframe");
		document.getElementById("container").appendChild(chrome);
		// console.log(document.getElementById("container"));
		// console.log(chrome.getBoundingClientRect())
		const rect = chrome.getBoundingClientRect();
		const scaleX = SIZE / rect.width;
		const scaleY = SIZE / rect.width;
		const scale = Math.min(scaleX, scaleY) * 1.025; // Uniform scaling
		const x = c * SIZE;
		const y = r * SIZE;
		const skewYAngle = c % 2 === 0 ? ANGLE : ANGLE * -1;

		chrome.setAttribute("width", SIZE);
		chrome.setAttribute("height", SIZE);
		chrome.setAttribute("fill", "#CCC");
		chrome.setAttribute("stroke", "#000");

		// Apply skew transform to the square around its center
		chrome.setAttribute(
			"transform",
			`translate(${x + SIZE / 2}, ${y + SIZE / 2
			}) skewY(${skewYAngle}) translate(${-SIZE / 2}, ${-SIZE / 2
			}) scale(${scale})`
		);

		// Apply filter based on column
		if (c % 2 === 0) {
			chrome.setAttribute("filter", "url(#brightness)");
		}

		var palette = random(colors);
		paintChrome(chrome, palette);
		addBlockFrame(chrome, palette);

		grid.node.appendChild(chrome);
		// chrome.remove();
	}

	function animate(from, axis, ease) {
		var grid = [ROWCOUNT, COLCOUNT];
		var tl = gsap.timeline({});
		tl.from(".blockframe", {
			duration: 1,
			opacity: 0,
			ease: "power1.inOut",
			stagger: {
				amount: 5,
				grid: grid,
				axis: axis,
				ease: ease,
				from: 0,
			},
		});
	}

	async function init() {
		// Get color palettes (i.e. the top palettes from ColourLovers: https://github.com/Experience-Monks/nice-color-palettes/blob/master/README.md)
		colors = await fetch(
			"https://unpkg.com/nice-color-palettes@3.0.0/100.json"
		).then((response) => response.json());
		generateNewGrid();
		// animate();
	}

	init();
</script>